# =============================================================================
# Main CI Workflow with Sequential Job Execution
# =============================================================================
#
# This workflow implements a fail-fast CI strategy where H2 tests run first,
# followed by more expensive database-specific tests only if H2 tests pass.
#
# WORKFLOW STRUCTURE:
# 1. build-test: Fast H2-only tests (embedded database, no external services)
# 2. postgres-test: PostgreSQL database tests (needs: build-test)
# 3. mysql-test: MySQL database tests (needs: build-test)
# 4. mariadb-test: MariaDB database tests (needs: build-test)
# 5. cockroachdb-test: CockroachDB database tests (needs: build-test)
# 6. db2-test: IBM DB2 database tests (needs: build-test)
# 7. multinode-test: Multinode failover/recovery tests (needs: build-test)
# 8. multinode-xa-test: Multinode XA integration tests (needs: build-test)
# 9. oracle-test: Oracle database tests (needs: build-test)
# 10. sqlserver-tests: SQL Server tests (needs: build-test)
# 11. notify-integration: Triggers integration repo workflow
#
# SEQUENTIAL EXECUTION:
# All specialized test jobs depend on build-test completing successfully.
# This ensures that expensive database setups only run if basic H2 tests pass,
# providing:
# - Fast feedback (H2 tests complete in seconds)
# - Resource efficiency (avoids running expensive tests when basics fail)
# - Cost savings (reduces CI minutes when tests would fail anyway)
#
# This sequential execution works on ALL branches (PRs, main, feature branches)
# because all jobs are defined in a single workflow file.
#
# =============================================================================

name: Main CI

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  # ===========================================================================
  # JOB 1: Build & Test with H2 (Fast Fail-Fast Gate)
  # ===========================================================================
  #
  # This job runs first and tests against H2 embedded database.
  # H2 requires no external services and runs in seconds, making it ideal
  # for catching basic issues before running expensive database-specific tests.
  #
  # Test execution: Runs with -DenableH2Tests=true flag
  # Matrix strategy: Tests against Java 11, 17, 21, 22
  #
  # ===========================================================================
  build-test:
    name: Build & Test (H2 - Fast Fail-Fast)
    runs-on: ubuntu-latest

    strategy:
      fail-fast: false
      matrix:
        java-version: [ 11, 17, 21, 22 ]

    steps:

      - name: Git checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up JDK 22 for build
        uses: actions/setup-java@v4
        with:
          java-version: 22
          distribution: 'temurin'
          cache: maven

      - name: Build and Install (ojp-grpc-commons) with JDK 22
        run: mvn clean install -pl ojp-grpc-commons -am -DskipTests -Dgpg.skip=true

      - name: Test (ojp-grpc-commons) with JDK 22
        run: mvn test -pl ojp-grpc-commons -Dgpg.skip=true

      - name: Build (ojp-server) with JDK 22
        run: mvn clean install -pl ojp-server -am -DskipTests -Dgpg.skip=true

      - name: Test and Run (ojp-server)
        run: |
          nohup java -jar ojp-server/target/ojp-server-0.3.2-snapshot-shaded.jar > /tmp/ojp-server.log 2>&1 &
          echo $! > /tmp/ojp-server.pid

      - name: Wait for ojp-server to start
        run: sleep 10

      - name: Set up JDK ${{ matrix.java-version }} for ojp-jdbc-driver
        uses: actions/setup-java@v4
        with:
          java-version: ${{ matrix.java-version }}
          distribution: 'temurin'
          cache: maven

      - name: Build (ojp-jdbc-driver) with JDK ${{ matrix.java-version }}
        run: mvn clean install -pl ojp-jdbc-driver -am -DskipTests -Dgpg.skip=true

      # This is the key test step - only H2 tests are enabled
      # All other database tests are disabled by default
      - name: Test (ojp-jdbc-driver) with H2 only
        run: mvn test -pl ojp-jdbc-driver -Dgpg.skip=true -DenableH2Tests=true

      - name: Show ojp-server.log
        if: always()  # ensures it runs even if previous steps fail
        run: cat /tmp/ojp-server.log || echo "/tmp/ojp-server.log not found"

  # ===========================================================================
  # JOB 2: PostgreSQL Integration Tests
  # ===========================================================================
  #
  # This job tests PostgreSQL database integration.
  # PostgreSQL is a popular open-source database with excellent JDBC support
  # and XA transaction capabilities.
  #
  # Database: PostgreSQL 17
  # Matrix strategy: Tests against Java 11, 17, 21, 22
  # Execution: Only runs AFTER build-test job succeeds (needs: [build-test])
  #
  # ===========================================================================
  postgres-test:
    name: PostgreSQL Tests (JDK ${{ matrix.java-version }})
    runs-on: ubuntu-latest
    # DEPENDENCY: This job only runs if build-test succeeds
    needs: [build-test]

    strategy:
      fail-fast: false
      matrix:
        java-version: [ 11, 17, 21, 22 ]

    steps:
      - name: Git checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # Start PostgreSQL container with XA transaction support
      - name: Start Postgres
        run: |
          docker run --name ojp-postgres \
            -e POSTGRES_USER=testuser \
            -e POSTGRES_PASSWORD=testpassword \
            -e POSTGRES_DB=defaultdb \
            -p 5432:5432 \
            -d postgres:17 \
            -c max_prepared_transactions=100
      
          # Wait for Postgres to become ready (up to 60s)
          timeout 60 bash -c 'until docker exec ojp-postgres pg_isready -U testuser -d defaultdb -h 127.0.0.1; do sleep 2; done'

          # Verify setting
          PGPASSWORD=testpassword psql -h 127.0.0.1 -U testuser -d defaultdb -c "SHOW max_prepared_transactions;"

      - name: Set up JDK 22 for build
        uses: actions/setup-java@v4
        with:
          java-version: 22
          distribution: 'temurin'
          cache: maven

      - name: Build and Install (ojp-grpc-commons) with JDK 22
        run: mvn clean install -pl ojp-grpc-commons -am -DskipTests -Dgpg.skip=true

      - name: Test (ojp-grpc-commons) with JDK 22
        run: mvn test -pl ojp-grpc-commons -Dgpg.skip=true

      - name: Build (ojp-server) with JDK 22
        run: mvn clean install -pl ojp-server -am -DskipTests -Dgpg.skip=true

      - name: Test and Run (ojp-server)
        run: |
          nohup java -jar ojp-server/target/ojp-server-0.3.2-snapshot-shaded.jar > /tmp/ojp-server.log 2>&1 &
          echo $! > /tmp/ojp-server.pid

      - name: Wait for ojp-server to start
        run: sleep 10

      - name: Set up JDK ${{ matrix.java-version }} for ojp-jdbc-driver
        uses: actions/setup-java@v4
        with:
          java-version: ${{ matrix.java-version }}
          distribution: 'temurin'
          cache: maven

      - name: Build (ojp-jdbc-driver) with JDK ${{ matrix.java-version }}
        run: mvn clean install -pl ojp-jdbc-driver -am -DskipTests -Dgpg.skip=true

      # Run PostgreSQL-specific tests with -DenablePostgresTests flag
      - name: Test (ojp-jdbc-driver) with PostgreSQL enabled
        run: mvn test -pl ojp-jdbc-driver -Dgpg.skip=true -DenablePostgresTests=true

      - name: Show ojp-server.log
        if: always()
        run: cat /tmp/ojp-server.log || echo "/tmp/ojp-server.log not found"

  # ===========================================================================
  # JOB 3: MySQL Integration Tests
  # ===========================================================================
  #
  # This job tests MySQL database integration.
  # MySQL is one of the most widely used open-source databases.
  #
  # Database: MySQL 8.0
  # Matrix strategy: Tests against Java 11, 17, 21, 22
  # Execution: Only runs AFTER build-test job succeeds (needs: [build-test])
  #
  # ===========================================================================
  mysql-test:
    name: MySQL Tests (JDK ${{ matrix.java-version }})
    runs-on: ubuntu-latest
    # DEPENDENCY: This job only runs if build-test succeeds
    needs: [build-test]

    strategy:
      fail-fast: false
      matrix:
        java-version: [ 11, 17, 21, 22 ]

    services:
      # MySQL database service container
      mysql:
        image: mysql:8.0
        env:
          MYSQL_DATABASE: defaultdb
          MYSQL_USER: testuser
          MYSQL_PASSWORD: testpassword
          MYSQL_ROOT_PASSWORD: rootpassword
        options: >-
          --health-cmd "mysqladmin ping"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=5
        ports:
          - 3306:3306

    steps:
      - name: Git checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up JDK 22 for build
        uses: actions/setup-java@v4
        with:
          java-version: 22
          distribution: 'temurin'
          cache: maven

      - name: Build and Install (ojp-grpc-commons) with JDK 22
        run: mvn clean install -pl ojp-grpc-commons -am -DskipTests -Dgpg.skip=true

      - name: Test (ojp-grpc-commons) with JDK 22
        run: mvn test -pl ojp-grpc-commons -Dgpg.skip=true

      - name: Build (ojp-server) with JDK 22
        run: mvn clean install -pl ojp-server -am -DskipTests -Dgpg.skip=true

      - name: Test and Run (ojp-server)
        run: |
          nohup java -jar ojp-server/target/ojp-server-0.3.2-snapshot-shaded.jar > /tmp/ojp-server.log 2>&1 &
          echo $! > /tmp/ojp-server.pid

      - name: Wait for ojp-server to start
        run: sleep 10

      - name: Set up JDK ${{ matrix.java-version }} for ojp-jdbc-driver
        uses: actions/setup-java@v4
        with:
          java-version: ${{ matrix.java-version }}
          distribution: 'temurin'
          cache: maven

      - name: Build (ojp-jdbc-driver) with JDK ${{ matrix.java-version }}
        run: mvn clean install -pl ojp-jdbc-driver -am -DskipTests -Dgpg.skip=true

      # Run MySQL-specific tests with -DenableMySQLTests flag
      - name: Test (ojp-jdbc-driver) with MySQL enabled
        run: mvn test -pl ojp-jdbc-driver -Dgpg.skip=true -DenableMySQLTests=true

      - name: Show ojp-server.log
        if: always()
        run: cat /tmp/ojp-server.log || echo "/tmp/ojp-server.log not found"

  # ===========================================================================
  # JOB 4: MariaDB Integration Tests
  # ===========================================================================
  #
  # This job tests MariaDB database integration.
  # MariaDB is a MySQL-compatible database with enhanced features.
  #
  # Database: MariaDB 10.11
  # Matrix strategy: Tests against Java 11, 17, 21, 22
  # Execution: Only runs AFTER build-test job succeeds (needs: [build-test])
  #
  # ===========================================================================
  mariadb-test:
    name: MariaDB Tests (JDK ${{ matrix.java-version }})
    runs-on: ubuntu-latest
    # DEPENDENCY: This job only runs if build-test succeeds
    needs: [build-test]

    strategy:
      fail-fast: false
      matrix:
        java-version: [ 11, 17, 21, 22 ]

    services:
      # MariaDB database service container
      mariadb:
        image: mariadb:10.11
        env:
          MARIADB_DATABASE: defaultdb
          MARIADB_USER: testuser
          MARIADB_PASSWORD: testpassword
          MARIADB_ROOT_PASSWORD: rootpassword
        options: >-
          --health-cmd "mysqladmin ping -h localhost -u root -prootpassword"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=5
        ports:
          - 3307:3306

    steps:
      - name: Git checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up JDK 22 for build
        uses: actions/setup-java@v4
        with:
          java-version: 22
          distribution: 'temurin'
          cache: maven

      - name: Build and Install (ojp-grpc-commons) with JDK 22
        run: mvn clean install -pl ojp-grpc-commons -am -DskipTests -Dgpg.skip=true

      - name: Test (ojp-grpc-commons) with JDK 22
        run: mvn test -pl ojp-grpc-commons -Dgpg.skip=true

      - name: Build (ojp-server) with JDK 22
        run: mvn clean install -pl ojp-server -am -DskipTests -Dgpg.skip=true

      - name: Test and Run (ojp-server)
        run: |
          nohup java -jar ojp-server/target/ojp-server-0.3.2-snapshot-shaded.jar > /tmp/ojp-server.log 2>&1 &
          echo $! > /tmp/ojp-server.pid

      - name: Wait for ojp-server to start
        run: sleep 10

      - name: Set up JDK ${{ matrix.java-version }} for ojp-jdbc-driver
        uses: actions/setup-java@v4
        with:
          java-version: ${{ matrix.java-version }}
          distribution: 'temurin'
          cache: maven

      - name: Build (ojp-jdbc-driver) with JDK ${{ matrix.java-version }}
        run: mvn clean install -pl ojp-jdbc-driver -am -DskipTests -Dgpg.skip=true

      # Run MariaDB-specific tests with -DenableMariaDBTests flag
      - name: Test (ojp-jdbc-driver) with MariaDB enabled
        run: mvn test -pl ojp-jdbc-driver -Dgpg.skip=true -DenableMariaDBTests=true

      - name: Show ojp-server.log
        if: always()
        run: cat /tmp/ojp-server.log || echo "/tmp/ojp-server.log not found"

  # ===========================================================================
  # JOB 5: CockroachDB Integration Tests
  # ===========================================================================
  #
  # This job tests CockroachDB database integration.
  # CockroachDB is a distributed SQL database compatible with PostgreSQL.
  #
  # Database: CockroachDB v24.3.4
  # Matrix strategy: Tests against Java 11, 17, 21, 22
  # Execution: Only runs AFTER build-test job succeeds (needs: [build-test])
  #
  # ===========================================================================
  cockroachdb-test:
    name: CockroachDB Tests (JDK ${{ matrix.java-version }})
    runs-on: ubuntu-latest
    # DEPENDENCY: This job only runs if build-test succeeds
    needs: [build-test]

    strategy:
      fail-fast: false
      matrix:
        java-version: [ 11, 17, 21, 22 ]

    steps:
      - name: Git checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # Start CockroachDB in insecure mode for testing
      - name: Start CockroachDB
        run: |
          docker run --name ojp-cockroachdb -p 26257:26257 -p 8080:8080 -d cockroachdb/cockroach:v24.3.4 start-single-node --insecure
          # Wait for CockroachDB to be ready
          timeout 60 bash -c 'until curl -f http://localhost:8080/health?ready=1 2>/dev/null; do sleep 2; done'

      - name: Set up JDK 22 for build
        uses: actions/setup-java@v4
        with:
          java-version: 22
          distribution: 'temurin'
          cache: maven

      - name: Build and Install (ojp-grpc-commons) with JDK 22
        run: mvn clean install -pl ojp-grpc-commons -am -DskipTests -Dgpg.skip=true

      - name: Test (ojp-grpc-commons) with JDK 22
        run: mvn test -pl ojp-grpc-commons -Dgpg.skip=true

      - name: Build (ojp-server) with JDK 22
        run: mvn clean install -pl ojp-server -am -DskipTests -Dgpg.skip=true

      - name: Test and Run (ojp-server)
        run: |
          nohup java -jar ojp-server/target/ojp-server-0.3.2-snapshot-shaded.jar > /tmp/ojp-server.log 2>&1 &
          echo $! > /tmp/ojp-server.pid

      - name: Wait for ojp-server to start
        run: sleep 10

      - name: Set up JDK ${{ matrix.java-version }} for ojp-jdbc-driver
        uses: actions/setup-java@v4
        with:
          java-version: ${{ matrix.java-version }}
          distribution: 'temurin'
          cache: maven

      - name: Build (ojp-jdbc-driver) with JDK ${{ matrix.java-version }}
        run: mvn clean install -pl ojp-jdbc-driver -am -DskipTests -Dgpg.skip=true

      # Run CockroachDB-specific tests with -DenableCockroachDBTests flag
      - name: Test (ojp-jdbc-driver) with CockroachDB enabled
        run: mvn test -pl ojp-jdbc-driver -Dgpg.skip=true -DenableCockroachDBTests=true

      - name: Show ojp-server.log
        if: always()
        run: cat /tmp/ojp-server.log || echo "/tmp/ojp-server.log not found"

  # ===========================================================================
  # JOB 6: DB2 Integration Tests  
  # ===========================================================================
  #
  # This job tests IBM DB2 database integration.
  # DB2 is an enterprise-grade database system from IBM.
  #
  # Database: IBM DB2 11.5.8.0
  # Matrix strategy: Tests against Java 11, 17, 21, 22
  # Execution: Only runs AFTER build-test job succeeds (needs: [build-test])
  #
  # Note: DB2 container is large and takes longer to start up.
  #
  # ===========================================================================
  db2-test:
    name: DB2 Tests (JDK ${{ matrix.java-version }})
    runs-on: ubuntu-latest
    # DEPENDENCY: This job only runs if build-test succeeds
    needs: [build-test]

    strategy:
      fail-fast: false
      matrix:
        java-version: [ 11, 17, 21, 22 ]

    steps:
      - name: Git checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # Start DB2 container (note: this is a large container and takes time to start)
      - name: Start DB2
        run: |
          docker run --name ojp-db2 \
            -e LICENSE=accept \
            -e DB2INSTANCE=db2inst1 \
            -e DB2INST1_PASSWORD=testpass \
            -e DBNAME=testdb \
            -e AUTOCONFIG=false \
            -e ARCHIVE_LOGS=false \
            -p 50000:50000 \
            --privileged=true \
            -d ibmcom/db2:11.5.8.0
          
          # Wait for DB2 to be ready with proper health check (can take 5-10 minutes)
          echo "Waiting for DB2 to start (this may take several minutes)..."
          
          # Check Docker logs for the "Setup has completed" message indicating DB2 is ready
          MAX_WAIT=600  # 10 minutes
          ELAPSED=0
          while [ $ELAPSED -lt $MAX_WAIT ]; do
            if docker logs ojp-db2 2>&1 | grep -q "Setup has completed"; then
              echo "DB2 setup completed after $ELAPSED seconds"
              break
            fi
            echo "Still waiting for DB2... ($ELAPSED seconds elapsed)"
            sleep 30
            ELAPSED=$((ELAPSED + 30))
          done
          
          if [ $ELAPSED -ge $MAX_WAIT ]; then
            echo "ERROR: DB2 did not start within $MAX_WAIT seconds"
            echo "Last 50 lines of DB2 logs:"
            docker logs ojp-db2 2>&1 | tail -50
            exit 1
          fi
          
          # Give DB2 time to fully initialize after setup message
          echo "DB2 setup complete, waiting for database activation..."
          sleep 60
          
          # Activate the database and verify connectivity
          echo "Activating DB2 database testdb..."
          docker exec ojp-db2 su - db2inst1 -c "db2 activate database testdb" || echo "Activation command issued"
          sleep 10
          
          # Test connectivity to ensure DB2 is ready
          echo "Testing DB2 connectivity..."
          MAX_CONN_WAIT=120
          CONN_ELAPSED=0
          while [ $CONN_ELAPSED -lt $MAX_CONN_WAIT ]; do
            if docker exec ojp-db2 su - db2inst1 -c "db2 connect to testdb user db2inst1 using testpass" 2>&1 | grep -q "Database Connection Information"; then
              echo "DB2 is accepting connections after $CONN_ELAPSED seconds"
              docker exec ojp-db2 su - db2inst1 -c "db2 disconnect testdb" || true
              break
            fi
            echo "DB2 not ready yet, waiting... ($CONN_ELAPSED seconds)"
            sleep 10
            CONN_ELAPSED=$((CONN_ELAPSED + 10))
          done
          
          if [ $CONN_ELAPSED -ge $MAX_CONN_WAIT ]; then
            echo "WARNING: DB2 connectivity test timed out, but continuing..."
            docker logs ojp-db2 2>&1 | tail -50
          fi
          
          echo "DB2 initialization complete"

      # Download DB2 JDBC driver and place in ojp-libs directory
      # Similar to Oracle, we handle it via drop-in mechanism
      - name: Download DB2 JDBC Driver to ojp-libs
        run: |
          # Create ojp-libs directory
          mkdir -p ojp-server/ojp-libs
          
          # Download DB2 JDBC driver from Maven Central
          echo "=== Downloading DB2 JDBC driver ==="
          mvn dependency:copy \
            -Dartifact=com.ibm.db2:jcc:11.5.9.0 \
            -DoutputDirectory=ojp-server/ojp-libs \
            -Dmdep.stripVersion=false
          
          # Verify the download
          echo "=== DB2 JDBC driver downloaded to ojp-libs ==="
          ls -lh ojp-server/ojp-libs/

      - name: Set up JDK 22 for build
        uses: actions/setup-java@v4
        with:
          java-version: 22
          distribution: 'temurin'
          cache: maven

      - name: Build and Install (ojp-grpc-commons) with JDK 22
        run: mvn clean install -pl ojp-grpc-commons -am -DskipTests -Dgpg.skip=true

      - name: Test (ojp-grpc-commons) with JDK 22
        run: mvn test -pl ojp-grpc-commons -Dgpg.skip=true

      - name: Build (ojp-server) with JDK 22
        run: mvn clean install -pl ojp-server -am -DskipTests -Dgpg.skip=true

      - name: Test and Run (ojp-server) with DB2 driver from ojp-libs
        run: |
          nohup java -Dojp.libs.path=ojp-server/ojp-libs -jar ojp-server/target/ojp-server-0.3.2-snapshot-shaded.jar > /tmp/ojp-server.log 2>&1 &
          echo $! > /tmp/ojp-server.pid

      - name: Wait for ojp-server to start
        run: sleep 10

      - name: Set up JDK ${{ matrix.java-version }} for ojp-jdbc-driver
        uses: actions/setup-java@v4
        with:
          java-version: ${{ matrix.java-version }}
          distribution: 'temurin'
          cache: maven

      - name: Build (ojp-jdbc-driver) with JDK ${{ matrix.java-version }}
        run: mvn clean install -pl ojp-jdbc-driver -am -DskipTests -Dgpg.skip=true

      # Run DB2-specific tests with -DenableDb2Tests flag
      - name: Test (ojp-jdbc-driver) with DB2 enabled
        run: mvn test -pl ojp-jdbc-driver -Dgpg.skip=true -DenableDb2Tests=true

      - name: Show ojp-server.log
        if: always()
        run: cat /tmp/ojp-server.log || echo "/tmp/ojp-server.log not found"

  # ===========================================================================
  # JOB 7: Multinode Integration Tests
  # ===========================================================================
  #
  # This job tests multinode functionality with TWO OJP server instances.
  # It verifies failover and recovery scenarios by:
  # 1. Starting two OJP servers on different ports (10591, 10592)
  # 2. Running tests that use both servers simultaneously
  # 3. Killing servers one at a time and verifying failover
  # 4. Restarting servers and verifying recovery
  #
  # Database: PostgreSQL (for multinode connection pooling tests)
  # Execution: Only runs AFTER build-test job succeeds (needs: [build-test])
  #
  # ===========================================================================
  multinode-test:
    name: Multinode Integration Test
    runs-on: ubuntu-latest
    # DEPENDENCY: This job only runs if build-test succeeds
    # This ensures we don't waste resources on multinode tests if H2 tests fail
    needs: [build-test]

    steps:
      - name: Git checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # Start PostgreSQL container for multinode tests
      # Configured with max_prepared_transactions=100 for XA support
      - name: Start Postgres
        run: |
          docker run --name ojp-postgres-multinode \
            -e POSTGRES_USER=testuser \
            -e POSTGRES_PASSWORD=testpassword \
            -e POSTGRES_DB=defaultdb \
            -p 5432:5432 \
            -d postgres:17 \
            -c max_prepared_transactions=100
      
          # Wait for Postgres to become ready (up to 60s)
          timeout 60 bash -c 'until docker exec ojp-postgres-multinode pg_isready -U testuser -d defaultdb -h 127.0.0.1; do sleep 2; done'

          # Verify setting
          PGPASSWORD=testpassword psql -h 127.0.0.1 -U testuser -d defaultdb -c "SHOW max_prepared_transactions;"

      - name: Set up JDK 22 for build
        uses: actions/setup-java@v4
        with:
          java-version: 22
          distribution: 'temurin'
          cache: maven

      - name: Build and Install (ojp-grpc-commons) with JDK 22
        run: mvn clean install -pl ojp-grpc-commons -am -DskipTests -Dgpg.skip=true

      - name: Test (ojp-grpc-commons) with JDK 22
        run: mvn test -pl ojp-grpc-commons -Dgpg.skip=true

      - name: Build (ojp-server) with JDK 22
        run: mvn clean install -pl ojp-server -am -DskipTests -Dgpg.skip=true

      # Start first OJP server instance on port 10591
      - name: Start OJP Server 1 on port 10591
        run: |
          # Start first server on port 10591 with Prometheus on 9159
          nohup java -Dojp.server.port=10591 -Dojp.prometheus.port=9159 -jar ojp-server/target/ojp-server-0.3.2-snapshot-shaded.jar > /tmp/ojp-server-1.log 2>&1 &
          echo $! > /tmp/ojp-server-1.pid
          echo "Started OJP Server 1 on gRPC port 10591, Prometheus port 9159 with PID $(cat /tmp/ojp-server-1.pid)"

      # Start second OJP server instance on port 10592
      - name: Start OJP Server 2 on port 10592
        run: |
          # Start second server on port 10592 with Prometheus on 9160
          nohup java -Dojp.server.port=10592 -Dojp.prometheus.port=9160 -jar ojp-server/target/ojp-server-0.3.2-snapshot-shaded.jar > /tmp/ojp-server-2.log 2>&1 &
          echo $! > /tmp/ojp-server-2.pid
          echo "Started OJP Server 2 on gRPC port 10592, Prometheus port 9160 with PID $(cat /tmp/ojp-server-2.pid)"

      - name: Wait for OJP servers to start
        run: |
          echo "Waiting for servers to start..."
          sleep 15
          echo "Checking if servers are listening..."
          netstat -tuln | grep -E ':(10591|10592)' || echo "Warning: Servers might not be listening yet"

      - name: Build (ojp-jdbc-driver) with JDK 22
        run: mvn clean install -pl ojp-jdbc-driver -am -DskipTests -Dgpg.skip=true

      - name: Create temp directory for test logs
        run: mkdir -p temp

      # Run the multinode integration test in background
      # This test will create connections to both servers and test failover scenarios
      - name: Start MultinodeIntegrationTest with nohup
        run: |
          echo "Starting MultinodeIntegrationTest in background..."
          nohup mvn test -pl ojp-jdbc-driver -Dtest=MultinodeIntegrationTest -DmultinodeTestsEnabled=true -Dgpg.skip=true > temp/MultinodeIntegrationTest.log 2>&1 &
          echo $! > temp/multinode-test.pid
          echo "MultinodeIntegrationTest started with PID $(cat temp/multinode-test.pid)"
          # Give test time to start
          sleep 20

      # Verify connection pooling is working correctly
      # Expected: 20-24 connections (10-12 per server)
      - name: Check PostgreSQL connections during test
        run: |
          echo "Checking PostgreSQL connections..."
          TIMEOUT=600
          ELAPSED=0
          
          while [ $ELAPSED -lt $TIMEOUT ]; do
            CONNECTION_COUNT=$(PGPASSWORD=testpassword psql -h 127.0.0.1 -U testuser -d defaultdb -t -c "SELECT COUNT(*) FROM pg_stat_activity WHERE datname='defaultdb';")
            CONNECTION_COUNT=$(echo $CONNECTION_COUNT | tr -d '[:space:]')
            echo "Current connections: $CONNECTION_COUNT (elapsed: ${ELAPSED}s)"
            
            if [ "$CONNECTION_COUNT" -ge 20 ] && [ "$CONNECTION_COUNT" -lt 25 ]; then
              echo "✓ Connection count is within expected range: 20 ≤ $CONNECTION_COUNT < 25"
              PGPASSWORD=testpassword psql -h 127.0.0.1 -U testuser -d defaultdb -c "SELECT datname, COUNT(*) AS connections FROM pg_stat_activity WHERE datname='defaultdb' GROUP BY datname ORDER BY connections DESC;"
              break
            elif [ "$CONNECTION_COUNT" -ge 25 ]; then
              echo "✗ ERROR: Connection count ($CONNECTION_COUNT) exceeds maximum of 25!"
              PGPASSWORD=testpassword psql -h 127.0.0.1 -U testuser -d defaultdb -c "SELECT datname, COUNT(*) AS connections FROM pg_stat_activity WHERE datname='defaultdb' GROUP BY datname ORDER BY connections DESC;"
              exit 1
            else
              echo "Waiting for connections to reach at least 20... (currently: $CONNECTION_COUNT)"
              sleep 2
              ELAPSED=$((ELAPSED + 2))
            fi
          done
          
          if [ $ELAPSED -ge $TIMEOUT ]; then
            echo "✗ ERROR: Timeout after ${TIMEOUT}s - connection count never reached 20 (current: $CONNECTION_COUNT)"
            exit 1
          fi

      # Test failover: Kill server 1 and verify connections migrate to server 2
      - name: Kill OJP Server 1
        run: |
          echo "Killing OJP Server 1..."
          if [ -f /tmp/ojp-server-1.pid ]; then
            kill $(cat /tmp/ojp-server-1.pid) || true
            echo "OJP Server 1 killed"
          fi
          sleep 10

      # Verify failover: Connections should still be active on server 2
      - name: Check PostgreSQL connections after killing Server 1
        run: |
          echo "Checking PostgreSQL connections after killing Server 1..."
          TIMEOUT=600
          ELAPSED=0
          
          while [ $ELAPSED -lt $TIMEOUT ]; do
            CONNECTION_COUNT=$(PGPASSWORD=testpassword psql -h 127.0.0.1 -U testuser -d defaultdb -t -c "SELECT COUNT(*) FROM pg_stat_activity WHERE datname='defaultdb';")
            CONNECTION_COUNT=$(echo $CONNECTION_COUNT | tr -d '[:space:]')
            echo "Current connections: $CONNECTION_COUNT (elapsed: ${ELAPSED}s)"
            
            if [ "$CONNECTION_COUNT" -ge 20 ] && [ "$CONNECTION_COUNT" -lt 25 ]; then
              echo "✓ Connection count is within expected range: 20 ≤ $CONNECTION_COUNT < 25"
              PGPASSWORD=testpassword psql -h 127.0.0.1 -U testuser -d defaultdb -c "SELECT datname, COUNT(*) AS connections FROM pg_stat_activity WHERE datname='defaultdb' GROUP BY datname ORDER BY connections DESC;"
              break
            elif [ "$CONNECTION_COUNT" -ge 25 ]; then
              echo "✗ ERROR: Connection count ($CONNECTION_COUNT) exceeds maximum of 25!"
              PGPASSWORD=testpassword psql -h 127.0.0.1 -U testuser -d defaultdb -c "SELECT datname, COUNT(*) AS connections FROM pg_stat_activity WHERE datname='defaultdb' GROUP BY datname ORDER BY connections DESC;"
              exit 1
            else
              echo "Waiting for connections to reach at least 20... (currently: $CONNECTION_COUNT)"
              sleep 2
              ELAPSED=$((ELAPSED + 2))
            fi
          done
          
          if [ $ELAPSED -ge $TIMEOUT ]; then
            echo "✗ ERROR: Timeout after ${ELAPSED}s - connection count never reached 20 (current: $CONNECTION_COUNT)"
            exit 1
          fi

      # Test recovery: Restart server 1 and verify it rejoins the cluster
      - name: Restart OJP Server 1
        run: |
          echo "Restarting OJP Server 1..."
          nohup java -Dojp.server.port=10591 -Dojp.prometheus.port=9159 -jar ojp-server/target/ojp-server-0.3.2-snapshot-shaded.jar > /tmp/ojp-server-1-restart.log 2>&1 &
          echo $! > /tmp/ojp-server-1-restart.pid
          echo "OJP Server 1 restarted with PID $(cat /tmp/ojp-server-1-restart.pid)"
          sleep 10

      # Verify recovery: Connections should be distributed across both servers again
      - name: Check PostgreSQL connections after restarting Server 1
        run: |
          echo "Checking PostgreSQL connections after restarting Server 1..."
          TIMEOUT=600
          ELAPSED=0
          
          while [ $ELAPSED -lt $TIMEOUT ]; do
            CONNECTION_COUNT=$(PGPASSWORD=testpassword psql -h 127.0.0.1 -U testuser -d defaultdb -t -c "SELECT COUNT(*) FROM pg_stat_activity WHERE datname='defaultdb';")
            CONNECTION_COUNT=$(echo $CONNECTION_COUNT | tr -d '[:space:]')
            echo "Current connections: $CONNECTION_COUNT (elapsed: ${ELAPSED}s)"
            
            if [ "$CONNECTION_COUNT" -ge 20 ] && [ "$CONNECTION_COUNT" -lt 25 ]; then
              echo "✓ Connection count is within expected range: 20 ≤ $CONNECTION_COUNT < 25"
              PGPASSWORD=testpassword psql -h 127.0.0.1 -U testuser -d defaultdb -c "SELECT datname, COUNT(*) AS connections FROM pg_stat_activity WHERE datname='defaultdb' GROUP BY datname ORDER BY connections DESC;"
              break
            elif [ "$CONNECTION_COUNT" -ge 25 ]; then
              echo "✗ ERROR: Connection count ($CONNECTION_COUNT) exceeds maximum of 25!"
              PGPASSWORD=testpassword psql -h 127.0.0.1 -U testuser -d defaultdb -c "SELECT datname, COUNT(*) AS connections FROM pg_stat_activity WHERE datname='defaultdb' GROUP BY datname ORDER BY connections DESC;"
              exit 1
            else
              echo "Waiting for connections to reach at least 20... (currently: $CONNECTION_COUNT)"
              sleep 2
              ELAPSED=$((ELAPSED + 2))
            fi
          done
          
          if [ $ELAPSED -ge $TIMEOUT ]; then
            echo "✗ ERROR: Timeout after ${TIMEOUT}s - connection count never reached 20 (current: $CONNECTION_COUNT)"
            exit 1
          fi

      # Test failover again: Kill server 2
      - name: Kill OJP Server 2
        run: |
          echo "Killing OJP Server 2..."
          if [ -f /tmp/ojp-server-2.pid ]; then
            kill $(cat /tmp/ojp-server-2.pid) || true
            echo "OJP Server 2 killed"
          fi
          sleep 10

      # Verify failover: Connections should migrate to server 1
      - name: Check PostgreSQL connections after killing Server 2
        run: |
          echo "Checking PostgreSQL connections after killing Server 2..."
          TIMEOUT=600
          ELAPSED=0
          
          while [ $ELAPSED -lt $TIMEOUT ]; do
            CONNECTION_COUNT=$(PGPASSWORD=testpassword psql -h 127.0.0.1 -U testuser -d defaultdb -t -c "SELECT COUNT(*) FROM pg_stat_activity WHERE datname='defaultdb';")
            CONNECTION_COUNT=$(echo $CONNECTION_COUNT | tr -d '[:space:]')
            echo "Current connections: $CONNECTION_COUNT (elapsed: ${ELAPSED}s)"
            
            if [ "$CONNECTION_COUNT" -ge 20 ] && [ "$CONNECTION_COUNT" -lt 25 ]; then
              echo "✓ Connection count is within expected range: 20 ≤ $CONNECTION_COUNT < 25"
              PGPASSWORD=testpassword psql -h 127.0.0.1 -U testuser -d defaultdb -c "SELECT datname, COUNT(*) AS connections FROM pg_stat_activity WHERE datname='defaultdb' GROUP BY datname ORDER BY connections DESC;"
              break
            elif [ "$CONNECTION_COUNT" -ge 25 ]; then
              echo "✗ ERROR: Connection count ($CONNECTION_COUNT) exceeds maximum of 25!"
              PGPASSWORD=testpassword psql -h 127.0.0.1 -U testuser -d defaultdb -c "SELECT datname, COUNT(*) AS connections FROM pg_stat_activity WHERE datname='defaultdb' GROUP BY datname ORDER BY connections DESC;"
              exit 1
            else
              echo "Waiting for connections to reach at least 20... (currently: $CONNECTION_COUNT)"
              sleep 2
              ELAPSED=$((ELAPSED + 2))
            fi
          done
          
          if [ $ELAPSED -ge $TIMEOUT ]; then
            echo "✗ ERROR: Timeout after ${TIMEOUT}s - connection count never reached 20 (current: $CONNECTION_COUNT)"
            exit 1
          fi

      # Test recovery again: Restart server 2
      - name: Restart OJP Server 2
        run: |
          echo "Restarting OJP Server 2..."
          nohup java -Dojp.server.port=10592 -Dojp.prometheus.port=9160 -jar ojp-server/target/ojp-server-0.3.2-snapshot-shaded.jar > /tmp/ojp-server-2-restart.log 2>&1 &
          echo $! > /tmp/ojp-server-2-restart.pid
          echo "OJP Server 2 restarted with PID $(cat /tmp/ojp-server-2-restart.pid)"
          sleep 10

      # Final verification: Both servers should be active
      - name: Check PostgreSQL connections after restarting Server 2
        run: |
          echo "Checking PostgreSQL connections after restarting Server 2..."
          TIMEOUT=600
          ELAPSED=0
          
          while [ $ELAPSED -lt $TIMEOUT ]; do
            CONNECTION_COUNT=$(PGPASSWORD=testpassword psql -h 127.0.0.1 -U testuser -d defaultdb -t -c "SELECT COUNT(*) FROM pg_stat_activity WHERE datname='defaultdb';")
            CONNECTION_COUNT=$(echo $CONNECTION_COUNT | tr -d '[:space:]')
            echo "Current connections: $CONNECTION_COUNT (elapsed: ${ELAPSED}s)"
            
            if [ "$CONNECTION_COUNT" -ge 20 ] && [ "$CONNECTION_COUNT" -lt 25 ]; then
              echo "✓ Connection count is within expected range: 20 ≤ $CONNECTION_COUNT < 25"
              PGPASSWORD=testpassword psql -h 127.0.0.1 -U testuser -d defaultdb -c "SELECT datname, COUNT(*) AS connections FROM pg_stat_activity WHERE datname='defaultdb' GROUP BY datname ORDER BY connections DESC;"
              break
            elif [ "$CONNECTION_COUNT" -ge 25 ]; then
              echo "✗ ERROR: Connection count ($CONNECTION_COUNT) exceeds maximum of 25!"
              PGPASSWORD=testpassword psql -h 127.0.0.1 -U testuser -d defaultdb -c "SELECT datname, COUNT(*) AS connections FROM pg_stat_activity WHERE datname='defaultdb' GROUP BY datname ORDER BY connections DESC;"
              exit 1
            else
              echo "Waiting for connections to reach at least 20... (currently: $CONNECTION_COUNT)"
              sleep 2
              ELAPSED=$((ELAPSED + 2))
            fi
          done
          
          if [ $ELAPSED -ge $TIMEOUT ]; then
            echo "✗ ERROR: Timeout after ${TIMEOUT}s - connection count never reached 20 (current: $CONNECTION_COUNT)"
            exit 1
          fi

      # Wait for the test process to complete
      - name: Wait for MultinodeIntegrationTest to complete
        run: |
          echo "Waiting for MultinodeIntegrationTest to complete..."
          # Wait for test process to finish (max 10 minutes)
          if [ -f temp/multinode-test.pid ]; then
            TEST_PID=$(cat temp/multinode-test.pid)
            TIMEOUT=600
            ELAPSED=0
            while kill -0 $TEST_PID 2>/dev/null && [ $ELAPSED -lt $TIMEOUT ]; do
              echo "Test still running... (${ELAPSED}s elapsed)"
              sleep 10
              ELAPSED=$((ELAPSED + 10))
            done
            
            if kill -0 $TEST_PID 2>/dev/null; then
              echo "Test did not complete within timeout, terminating..."
              kill $TEST_PID || true
            else
              echo "Test completed successfully"
            fi
          fi

      # Verify the test actually passed
      - name: Verify test results
        run: |
          echo "Checking MultinodeIntegrationTest results..."
          if grep -q "BUILD SUCCESS" temp/MultinodeIntegrationTest.log; then
            echo "✓ Test passed successfully"
          elif grep -q "BUILD FAILURE" temp/MultinodeIntegrationTest.log; then
            echo "✗ Test failed"
            exit 1
          else
            echo "⚠ Could not determine test status"
          fi

      # Show logs for debugging (runs even if test fails)
      - name: Show OJP Server 1 log
        if: always()
        run: |
          echo "=== OJP Server 1 Initial Log ==="
          cat /tmp/ojp-server-1.log || echo "/tmp/ojp-server-1.log not found"
          echo ""
          echo "=== OJP Server 1 Restart Log ==="
          cat /tmp/ojp-server-1-restart.log || echo "/tmp/ojp-server-1-restart.log not found"

      - name: Show OJP Server 2 log
        if: always()
        run: |
          echo "=== OJP Server 2 Initial Log ==="
          cat /tmp/ojp-server-2.log || echo "/tmp/ojp-server-2.log not found"
          echo ""
          echo "=== OJP Server 2 Restart Log ==="
          cat /tmp/ojp-server-2-restart.log || echo "/tmp/ojp-server-2-restart.log not found"

      - name: Show MultinodeIntegrationTest log
        if: always()
        run: |
          echo "=== MultinodeIntegrationTest Log ==="
          cat temp/MultinodeIntegrationTest.log || echo "temp/MultinodeIntegrationTest.log not found"

      # Clean up resources
      - name: Cleanup
        if: always()
        run: |
          # Kill any remaining OJP server processes
          pkill -f "ojp-server-0.3.2-snapshot-shaded.jar" || true
          # Stop Postgres container
          docker stop ojp-postgres-multinode || true
          docker rm ojp-postgres-multinode || true

  # ===========================================================================
  # JOB 8: Multinode XA Integration Tests
  # ===========================================================================
  #
  # This job tests multinode functionality with XA (eXtended Architecture) 
  # distributed transactions using TWO OJP server instances.
  # It verifies XA transaction support and failover scenarios by:
  # 1. Starting two OJP servers on different ports (10591, 10592)
  # 2. Running tests that use XA connections to both servers
  # 3. Killing servers one at a time and verifying XA failover
  # 4. Restarting servers and verifying XA recovery
  #
  # Database: PostgreSQL (with XA prepared transactions support)
  # Execution: Only runs AFTER build-test job succeeds (needs: [build-test])
  #
  # NOTE: Connection count checks expect 20-25 connections (XA pool only, non-XA pool disabled).
  #
  # ===========================================================================
  multinode-xa-test:
    name: Multinode XA Integration Test
    runs-on: ubuntu-latest
    # DEPENDENCY: This job only runs if build-test succeeds
    # This ensures we don't waste resources on multinode XA tests if H2 tests fail
    needs: [build-test]

    steps:
      - name: Git checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # Start PostgreSQL container for multinode XA tests
      # Configured with max_prepared_transactions=100 for XA support
      - name: Start Postgres
        run: |
          docker run --name ojp-postgres-multinode-xa \
            -e POSTGRES_USER=testuser \
            -e POSTGRES_PASSWORD=testpassword \
            -e POSTGRES_DB=defaultdb \
            -p 5432:5432 \
            -d postgres:17 \
            -c max_prepared_transactions=100
      
          # Wait for Postgres to become ready (up to 60s)
          timeout 60 bash -c 'until docker exec ojp-postgres-multinode-xa pg_isready -U testuser -d defaultdb -h 127.0.0.1; do sleep 2; done'

          # Verify setting
          PGPASSWORD=testpassword psql -h 127.0.0.1 -U testuser -d defaultdb -c "SHOW max_prepared_transactions;"

      - name: Set up JDK 22 for build
        uses: actions/setup-java@v4
        with:
          java-version: 22
          distribution: 'temurin'
          cache: maven

      - name: Build and Install (ojp-grpc-commons) with JDK 22
        run: mvn clean install -pl ojp-grpc-commons -am -DskipTests -Dgpg.skip=true

      - name: Test (ojp-grpc-commons) with JDK 22
        run: mvn test -pl ojp-grpc-commons -Dgpg.skip=true

      - name: Build (ojp-server) with JDK 22
        run: mvn clean install -pl ojp-server -am -DskipTests -Dgpg.skip=true

      # Start first OJP server instance on port 10591 with DEBUG logging
      - name: Start OJP Server 1 on port 10591
        run: |
          # Start first server on port 10591 with Prometheus on 9161 (different from multinode-test to avoid conflicts)
          # Enable DEBUG logging for XA pool operations
          nohup java -Dojp.server.port=10591 -Dojp.prometheus.port=9161 -Dorg.slf4j.simpleLogger.log.org.openjproxy.xa.pool=DEBUG -jar ojp-server/target/ojp-server-0.3.2-snapshot-shaded.jar > /tmp/ojp-server-xa-1.log 2>&1 &
          echo $! > /tmp/ojp-server-xa-1.pid
          echo "Started OJP Server 1 on gRPC port 10591, Prometheus port 9161 with DEBUG logging, PID $(cat /tmp/ojp-server-xa-1.pid)"

      # Start second OJP server instance on port 10592 with DEBUG logging
      - name: Start OJP Server 2 on port 10592
        run: |
          # Start second server on port 10592 with Prometheus on 9162 (different from multinode-test to avoid conflicts)
          # Enable DEBUG logging for XA pool operations
          nohup java -Dojp.server.port=10592 -Dojp.prometheus.port=9162 -Dorg.slf4j.simpleLogger.log.org.openjproxy.xa.pool=DEBUG -jar ojp-server/target/ojp-server-0.3.2-snapshot-shaded.jar > /tmp/ojp-server-xa-2.log 2>&1 &
          echo $! > /tmp/ojp-server-xa-2.pid
          echo "Started OJP Server 2 on gRPC port 10592, Prometheus port 9162 with DEBUG logging, PID $(cat /tmp/ojp-server-xa-2.pid)"

      - name: Wait for OJP servers to start
        run: |
          echo "Waiting for servers to start..."
          sleep 15
          echo "Checking if servers are listening..."
          netstat -tuln | grep -E ':(10591|10592)' || echo "Warning: Servers might not be listening yet"

      - name: Build (ojp-jdbc-driver) with JDK 22
        run: mvn clean install -pl ojp-jdbc-driver -am -DskipTests -Dgpg.skip=true

      - name: Create temp directory for test logs
        run: mkdir -p temp

      # Run the multinode XA integration test in background with DEBUG logging for org.openjproxy packages only
      # This test will create XA connections to both servers and test failover scenarios
      # Note: Disabling non-XA pooling via system property to isolate XA connection behavior
      - name: Start MultinodeXAIntegrationTest with nohup
        run: |
          echo "Starting MultinodeXAIntegrationTest in background with DEBUG logging..."
          nohup mvn test -pl ojp-jdbc-driver -Dtest=MultinodeXAIntegrationTest -DmultinodeXATestsEnabled=true -Dgpg.skip=true -Dorg.slf4j.simpleLogger.log.org.openjproxy=DEBUG -Dorg.slf4j.simpleLogger.log.org.openjproxy.jdbc.ResultSet=INFO -Dmultinode.ojp.connection.pool.enabled=false > temp/MultinodeXAIntegrationTest.log 2>&1 &
          echo $! > temp/multinode-xa-test.pid
          echo "MultinodeXAIntegrationTest started with DEBUG logging, PID $(cat temp/multinode-xa-test.pid)"
          # Give test time to start
          sleep 20

      # Verify XA connection pooling is working
      # Expected range: 20-25 connections (XA pool only, non-XA pool disabled)
      # - XA pool max: 22 connections per server
      # - Plus 1-3 connections for SQL queries that count the connections themselves
      # - Lower bound of 20 accounts for partial pool initialization or connection release timing
      - name: Check PostgreSQL connections during XA test
        run: |
          echo "Checking PostgreSQL connections..."
          TIMEOUT=600
          ELAPSED=0
          
          while [ $ELAPSED -lt $TIMEOUT ]; do
            CONNECTION_COUNT=$(PGPASSWORD=testpassword psql -h 127.0.0.1 -U testuser -d defaultdb -t -c "SELECT COUNT(*) FROM pg_stat_activity WHERE datname='defaultdb';")
            CONNECTION_COUNT=$(echo $CONNECTION_COUNT | tr -d '[:space:]')
            echo "Current connections: $CONNECTION_COUNT (elapsed: ${ELAPSED}s)"
            
            # Check for 20-25 connections (XA pool only, non-XA pool disabled)
            if [ "$CONNECTION_COUNT" -ge 20 ] && [ "$CONNECTION_COUNT" -le 25 ]; then
              echo "✓ Connection count is within expected range: 20 ≤ $CONNECTION_COUNT ≤ 25"
              PGPASSWORD=testpassword psql -h 127.0.0.1 -U testuser -d defaultdb -c "SELECT datname, COUNT(*) AS connections FROM pg_stat_activity WHERE datname='defaultdb' GROUP BY datname ORDER BY connections DESC;"
              break
            elif [ "$CONNECTION_COUNT" -gt 25 ]; then
              echo "✗ ERROR: Connection count ($CONNECTION_COUNT) exceeds expected maximum of 25!"
              PGPASSWORD=testpassword psql -h 127.0.0.1 -U testuser -d defaultdb -c "SELECT datname, COUNT(*) AS connections FROM pg_stat_activity WHERE datname='defaultdb' GROUP BY datname ORDER BY connections DESC;"
              exit 1
            else
              echo "Waiting for connections to reach at least 20... (currently: $CONNECTION_COUNT)"
              sleep 2
              ELAPSED=$((ELAPSED + 2))
            fi
          done
          
          if [ $ELAPSED -ge $TIMEOUT ]; then
            echo "✗ ERROR: Timeout after ${TIMEOUT}s - connection count never reached 20 (current: $CONNECTION_COUNT)"
            exit 1
          fi

      # Test XA failover: Kill server 1 and verify XA transactions can continue on server 2
      - name: Kill OJP Server 1
        run: |
          echo "Killing OJP Server 1..."
          if [ -f /tmp/ojp-server-xa-1.pid ]; then
            SERVER_PID=$(cat /tmp/ojp-server-xa-1.pid)
            kill $SERVER_PID || true
            
            # Wait for process to fully terminate (max 30s)
            echo "Waiting for server process to terminate..."
            for i in {1..30}; do
              if ! kill -0 $SERVER_PID 2>/dev/null; then
                echo "Server process terminated after ${i}s"
                break
              fi
              sleep 1
            done
            
            # Force kill if still alive
            if kill -0 $SERVER_PID 2>/dev/null; then
              echo "Force killing server process..."
              kill -9 $SERVER_PID || true
              sleep 2
            fi
            
            # Wait for Prometheus port 9161 to be released
            echo "Waiting for Prometheus port 9161 to be released..."
            for i in {1..30}; do
              if ! netstat -tuln | grep -q ':9161 '; then
                echo "Port 9161 is now free after ${i}s"
                break
              fi
              sleep 1
            done
            
            echo "OJP Server 1 killed and ports released"
          fi
          sleep 5

      # Verify XA failover: Connections should still be active on server 2
      # Expected range: 20-25 connections (XA pool only, non-XA pool disabled)
      # - XA pool max: 22 connections per server
      # - Plus 1-3 connections for SQL queries that count the connections themselves
      # - Lower bound of 20 accounts for partial pool initialization or connection release timing
      # - During pool rebalancing, temporary spikes above 25 are allowed for up to 600 seconds (same as lower bound)
      - name: Check PostgreSQL connections after killing Server 1
        run: |
          echo "Checking PostgreSQL connections after killing Server 1..."
          TIMEOUT=600
          ELAPSED=0
          
          while [ $ELAPSED -lt $TIMEOUT ]; do
            CONNECTION_COUNT=$(PGPASSWORD=testpassword psql -h 127.0.0.1 -U testuser -d defaultdb -t -c "SELECT COUNT(*) FROM pg_stat_activity WHERE datname='defaultdb';")
            CONNECTION_COUNT=$(echo $CONNECTION_COUNT | tr -d '[:space:]')
            echo "Current connections: $CONNECTION_COUNT (elapsed: ${ELAPSED}s)"
            
            if [ "$CONNECTION_COUNT" -ge 20 ] && [ "$CONNECTION_COUNT" -le 25 ]; then
              echo "✓ Connection count is within expected range: 20 ≤ $CONNECTION_COUNT ≤ 25"
              PGPASSWORD=testpassword psql -h 127.0.0.1 -U testuser -d defaultdb -c "SELECT datname, COUNT(*) AS connections FROM pg_stat_activity WHERE datname='defaultdb' GROUP BY datname ORDER BY connections DESC;"
              break
            elif [ "$CONNECTION_COUNT" -gt 25 ]; then
              # Allow temporary spike during pool rebalancing - wait up to TIMEOUT (600s) same as lower bound
              echo "⚠ Connection count temporarily high ($CONNECTION_COUNT > 25), waiting for pool rebalancing..."
            else
              # Count is below minimum - wait for connections to grow
              echo "Waiting for connections to reach at least 20... (currently: $CONNECTION_COUNT)"
            fi
            
            sleep 2
            ELAPSED=$((ELAPSED + 2))
          done
          
          if [ $ELAPSED -ge $TIMEOUT ]; then
            echo "✗ ERROR: Timeout after ${TIMEOUT}s - connection count never stabilized in range 20-25 (current: $CONNECTION_COUNT)"
            exit 1
          fi

      # Test XA recovery: Restart server 1 and verify it rejoins the cluster
      - name: Restart OJP Server 1
        run: |
          echo "Restarting OJP Server 1..."
          
          # Double-check ports are free before restarting
          echo "Verifying ports 10591 and 9161 are available..."
          if netstat -tuln | grep -q ':10591 '; then
            echo "Warning: Port 10591 still in use, waiting..."
            sleep 5
          fi
          if netstat -tuln | grep -q ':9161 '; then
            echo "Warning: Port 9161 still in use, waiting..."
            sleep 5
          fi
          
          # Start server
          nohup java -Dojp.server.port=10591 -Dojp.prometheus.port=9161 -jar ojp-server/target/ojp-server-0.3.2-snapshot-shaded.jar > /tmp/ojp-server-xa-1-restart.log 2>&1 &
          echo $! > /tmp/ojp-server-xa-1-restart.pid
          echo "OJP Server 1 restarted with PID $(cat /tmp/ojp-server-xa-1-restart.pid)"
          
          # Wait for server to fully start
          sleep 15
          
          # Verify server is listening
          echo "Verifying server is listening on port 10591..."
          netstat -tuln | grep ':10591' || echo "Warning: Server might not be listening yet"

      # Verify XA recovery: Connections should be distributed across both servers again
      # Expected range: 20-25 connections (XA pool only, non-XA pool disabled)
      # - XA pool max: 22 connections per server
      # - Plus 1-3 connections for SQL queries that count the connections themselves
      # - Lower bound of 20 accounts for partial pool initialization or connection release timing
      # - During pool rebalancing, temporary spikes above 25 are allowed for up to 15 seconds
      - name: Check PostgreSQL connections after restarting Server 1
        run: |
          echo "Checking PostgreSQL connections after restarting Server 1..."
          TIMEOUT=600
          ELAPSED=0
          
          while [ $ELAPSED -lt $TIMEOUT ]; do
            CONNECTION_COUNT=$(PGPASSWORD=testpassword psql -h 127.0.0.1 -U testuser -d defaultdb -t -c "SELECT COUNT(*) FROM pg_stat_activity WHERE datname='defaultdb';")
            CONNECTION_COUNT=$(echo $CONNECTION_COUNT | tr -d '[:space:]')
            echo "Current connections: $CONNECTION_COUNT (elapsed: ${ELAPSED}s)"
            
            if [ "$CONNECTION_COUNT" -ge 20 ] && [ "$CONNECTION_COUNT" -le 25 ]; then
              echo "✓ Connection count is within expected range: 20 ≤ $CONNECTION_COUNT ≤ 25"
              PGPASSWORD=testpassword psql -h 127.0.0.1 -U testuser -d defaultdb -c "SELECT datname, COUNT(*) AS connections FROM pg_stat_activity WHERE datname='defaultdb' GROUP BY datname ORDER BY connections DESC;"
              break
            elif [ "$CONNECTION_COUNT" -gt 25 ]; then
              # Allow temporary spike during pool rebalancing - wait up to TIMEOUT (600s) same as lower bound
              echo "⚠ Connection count temporarily high ($CONNECTION_COUNT > 25), waiting for pool rebalancing..."
            else
              # Count is below minimum - wait for connections to grow
              echo "Waiting for connections to reach at least 20... (currently: $CONNECTION_COUNT)"
            fi
            
            sleep 2
            ELAPSED=$((ELAPSED + 2))
          done
          
          if [ $ELAPSED -ge $TIMEOUT ]; then
            echo "✗ ERROR: Timeout after ${TIMEOUT}s - connection count never stabilized in range 20-25 (current: $CONNECTION_COUNT)"
            exit 1
          fi

      # Test XA failover again: Kill server 2
      - name: Kill OJP Server 2
        run: |
          echo "Killing OJP Server 2..."
          if [ -f /tmp/ojp-server-xa-2.pid ]; then
            SERVER_PID=$(cat /tmp/ojp-server-xa-2.pid)
            kill $SERVER_PID || true
            
            # Wait for process to fully terminate (max 30s)
            echo "Waiting for server process to terminate..."
            for i in {1..30}; do
              if ! kill -0 $SERVER_PID 2>/dev/null; then
                echo "Server process terminated after ${i}s"
                break
              fi
              sleep 1
            done
            
            # Force kill if still alive
            if kill -0 $SERVER_PID 2>/dev/null; then
              echo "Force killing server process..."
              kill -9 $SERVER_PID || true
              sleep 2
            fi
            
            # Wait for Prometheus port 9162 to be released
            echo "Waiting for Prometheus port 9162 to be released..."
            for i in {1..30}; do
              if ! netstat -tuln | grep -q ':9162 '; then
                echo "Port 9162 is now free after ${i}s"
                break
              fi
              sleep 1
            done
            
            echo "OJP Server 2 killed and ports released"
          fi
          sleep 5

      # Verify XA failover: Connections should migrate to server 1
      # Expected range: 20-25 connections (XA pool only, non-XA pool disabled)
      # - XA pool max: 22 connections per server
      # - Plus 1-3 connections for SQL queries that count the connections themselves
      # - Lower bound of 20 accounts for partial pool initialization or connection release timing
      # - During pool rebalancing, temporary spikes above 25 are allowed for up to 15 seconds
      - name: Check PostgreSQL connections after killing Server 2
        run: |
          echo "Checking PostgreSQL connections after killing Server 2..."
          TIMEOUT=600
          ELAPSED=0
          
          while [ $ELAPSED -lt $TIMEOUT ]; do
            CONNECTION_COUNT=$(PGPASSWORD=testpassword psql -h 127.0.0.1 -U testuser -d defaultdb -t -c "SELECT COUNT(*) FROM pg_stat_activity WHERE datname='defaultdb';")
            CONNECTION_COUNT=$(echo $CONNECTION_COUNT | tr -d '[:space:]')
            echo "Current connections: $CONNECTION_COUNT (elapsed: ${ELAPSED}s)"
            
            if [ "$CONNECTION_COUNT" -ge 20 ] && [ "$CONNECTION_COUNT" -le 25 ]; then
              echo "✓ Connection count is within expected range: 20 ≤ $CONNECTION_COUNT ≤ 25"
              PGPASSWORD=testpassword psql -h 127.0.0.1 -U testuser -d defaultdb -c "SELECT datname, COUNT(*) AS connections FROM pg_stat_activity WHERE datname='defaultdb' GROUP BY datname ORDER BY connections DESC;"
              break
            elif [ "$CONNECTION_COUNT" -gt 25 ]; then
              # Allow temporary spike during pool rebalancing - wait up to TIMEOUT (600s) same as lower bound
              echo "⚠ Connection count temporarily high ($CONNECTION_COUNT > 25), waiting for pool rebalancing..."
            else
              # Count is below minimum - wait for connections to grow
              echo "Waiting for connections to reach at least 20... (currently: $CONNECTION_COUNT)"
            fi
            
            sleep 2
            ELAPSED=$((ELAPSED + 2))
          done
          
          if [ $ELAPSED -ge $TIMEOUT ]; then
            echo "✗ ERROR: Timeout after ${TIMEOUT}s - connection count never stabilized in range 20-25 (current: $CONNECTION_COUNT)"
            exit 1
          fi

      # Test XA recovery again: Restart server 2
      - name: Restart OJP Server 2
        run: |
          echo "Restarting OJP Server 2..."
          
          # Double-check ports are free before restarting
          echo "Verifying ports 10592 and 9162 are available..."
          if netstat -tuln | grep -q ':10592 '; then
            echo "Warning: Port 10592 still in use, waiting..."
            sleep 5
          fi
          if netstat -tuln | grep -q ':9162 '; then
            echo "Warning: Port 9162 still in use, waiting..."
            sleep 5
          fi
          
          # Start server
          nohup java -Dojp.server.port=10592 -Dojp.prometheus.port=9162 -jar ojp-server/target/ojp-server-0.3.2-snapshot-shaded.jar > /tmp/ojp-server-xa-2-restart.log 2>&1 &
          echo $! > /tmp/ojp-server-xa-2-restart.pid
          echo "OJP Server 2 restarted with PID $(cat /tmp/ojp-server-xa-2-restart.pid)"
          
          # Wait for server to fully start
          sleep 15
          
          # Verify server is listening
          echo "Verifying server is listening on port 10592..."
          netstat -tuln | grep ':10592' || echo "Warning: Server might not be listening yet"

      # Final XA verification: Both servers should be active
      # Expected range: 20-25 connections (XA pool only, non-XA pool disabled)
      # - XA pool max: 22 connections per server
      # - Plus 1-3 connections for SQL queries that count the connections themselves
      # - Lower bound of 20 accounts for partial pool initialization or connection release timing
      # - During pool rebalancing, temporary spikes above 25 are allowed for up to 15 seconds
      - name: Check PostgreSQL connections after restarting Server 2
        run: |
          echo "Checking PostgreSQL connections after restarting Server 2..."
          TIMEOUT=600
          ELAPSED=0
          
          while [ $ELAPSED -lt $TIMEOUT ]; do
            CONNECTION_COUNT=$(PGPASSWORD=testpassword psql -h 127.0.0.1 -U testuser -d defaultdb -t -c "SELECT COUNT(*) FROM pg_stat_activity WHERE datname='defaultdb';")
            CONNECTION_COUNT=$(echo $CONNECTION_COUNT | tr -d '[:space:]')
            echo "Current connections: $CONNECTION_COUNT (elapsed: ${ELAPSED}s)"
            
            if [ "$CONNECTION_COUNT" -ge 20 ] && [ "$CONNECTION_COUNT" -le 25 ]; then
              echo "✓ Connection count is within expected range: 20 ≤ $CONNECTION_COUNT ≤ 25"
              PGPASSWORD=testpassword psql -h 127.0.0.1 -U testuser -d defaultdb -c "SELECT datname, COUNT(*) AS connections FROM pg_stat_activity WHERE datname='defaultdb' GROUP BY datname ORDER BY connections DESC;"
              break
            elif [ "$CONNECTION_COUNT" -gt 25 ]; then
              # Allow temporary spike during pool rebalancing - wait up to TIMEOUT (600s) same as lower bound
              echo "⚠ Connection count temporarily high ($CONNECTION_COUNT > 25), waiting for pool rebalancing..."
            else
              # Count is below minimum - wait for connections to grow
              echo "Waiting for connections to reach at least 20... (currently: $CONNECTION_COUNT)"
            fi
            
            sleep 2
            ELAPSED=$((ELAPSED + 2))
          done
          
          if [ $ELAPSED -ge $TIMEOUT ]; then
            echo "✗ ERROR: Timeout after ${TIMEOUT}s - connection count never stabilized in range 20-25 (current: $CONNECTION_COUNT)"
            exit 1
          fi

      # Wait for the XA test process to complete
      - name: Wait for MultinodeXAIntegrationTest to complete
        run: |
          echo "Waiting for MultinodeXAIntegrationTest to complete..."
          # Wait for test process to finish (max 10 minutes)
          if [ -f temp/multinode-xa-test.pid ]; then
            TEST_PID=$(cat temp/multinode-xa-test.pid)
            TIMEOUT=600
            ELAPSED=0
            while kill -0 $TEST_PID 2>/dev/null && [ $ELAPSED -lt $TIMEOUT ]; do
              echo "Test still running... (${ELAPSED}s elapsed)"
              sleep 10
              ELAPSED=$((ELAPSED + 10))
            done
            
            if kill -0 $TEST_PID 2>/dev/null; then
              echo "Test did not complete within timeout, terminating..."
              kill $TEST_PID || true
            else
              echo "Test completed successfully"
            fi
          fi

      # Verify the XA test actually passed
      - name: Verify test results
        run: |
          echo "Checking MultinodeXAIntegrationTest results..."
          if grep -q "BUILD SUCCESS" temp/MultinodeXAIntegrationTest.log; then
            echo "✓ Test passed successfully"
          elif grep -q "BUILD FAILURE" temp/MultinodeXAIntegrationTest.log; then
            echo "✗ Test failed"
            exit 1
          else
            echo "⚠ Could not determine test status"
          fi

      # Show logs for debugging (runs even if test fails)
      - name: Show OJP Server 1 log
        if: always()
        run: |
          echo "=== OJP Server 1 Initial Log ==="
          cat /tmp/ojp-server-xa-1.log || echo "/tmp/ojp-server-xa-1.log not found"
          echo ""
          echo "=== OJP Server 1 Restart Log ==="
          cat /tmp/ojp-server-xa-1-restart.log || echo "/tmp/ojp-server-xa-1-restart.log not found"

      - name: Show OJP Server 2 log
        if: always()
        run: |
          echo "=== OJP Server 2 Initial Log ==="
          cat /tmp/ojp-server-xa-2.log || echo "/tmp/ojp-server-xa-2.log not found"
          echo ""
          echo "=== OJP Server 2 Restart Log ==="
          cat /tmp/ojp-server-xa-2-restart.log || echo "/tmp/ojp-server-xa-2-restart.log not found"

      - name: Show MultinodeXAIntegrationTest log
        if: always()
        run: |
          echo "=== MultinodeXAIntegrationTest Log ==="
          cat temp/MultinodeXAIntegrationTest.log || echo "temp/MultinodeXAIntegrationTest.log not found"

      # Clean up resources
      - name: Cleanup
        if: always()
        run: |
          # Kill any remaining OJP server processes
          pkill -f "ojp-server-0.3.2-snapshot-shaded.jar" || true
          # Stop Postgres container
          docker stop ojp-postgres-multinode-xa || true
          docker rm ojp-postgres-multinode-xa || true

  # ===========================================================================
  # JOB 9: Oracle Database Testing
  # ===========================================================================
  #
  # This job tests Oracle Database integration.
  # Oracle JDBC driver is dynamically added during CI (not in repository due
  # to licensing). The test uses Oracle XE container with full configuration.
  #
  # Database: Oracle XE 21c
  # Matrix strategy: Tests against Java 11, 17, 21, 22
  # Execution: Only runs AFTER build-test job succeeds (needs: [build-test])
  #
  # ===========================================================================
  oracle-test:
    name: Oracle Tests (JDK ${{ matrix.java-version }})
    runs-on: ubuntu-latest
    # DEPENDENCY: This job only runs if build-test succeeds
    # This ensures we don't waste resources on Oracle tests if H2 tests fail
    needs: [build-test]
    
    permissions:
      contents: read

    strategy:
      fail-fast: false
      matrix:
        java-version: [ 11, 17, 21, 22 ]

    services:
      # Oracle XE database service container
      # Configured with testuser/testpassword for testing
      oracle:
        image: gvenzl/oracle-xe:21-full
        env:
          ORACLE_PASSWORD: testpassword
          APP_USER: testuser
          APP_USER_PASSWORD: testpassword
        options: >-
          --name ojp-oracle
          --health-cmd "echo 'SELECT 1 FROM DUAL;' | sqlplus -s system/testpassword@localhost/XEPDB1"
          --health-interval 20s
          --health-timeout 10s
          --health-retries 10
        ports:
          - 1521:1521

    steps:

      - name: Git checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # Grant XA (eXtended Architecture) permissions for distributed transactions
      # Oracle requires specific privileges for XA transaction support
      - name: Grant XA permissions to Oracle test user
        run: |
          # Wait a bit for Oracle to be fully ready
          sleep 5
          
          # Grant XA permissions to testuser
          echo "=== Granting XA permissions to testuser ==="
          
          docker exec ojp-oracle sqlplus -s system/testpassword@localhost/XEPDB1 <<'EOF'
          SET ECHO ON
          SET FEEDBACK ON
          SET SERVEROUTPUT ON
          WHENEVER SQLERROR EXIT SQL.SQLCODE
          
          -- Grant XA_RECOVER_ADMIN role (Oracle 12c+) for XA transaction recovery
          -- This role includes necessary privileges for XA operations
          GRANT XA_RECOVER_ADMIN TO testuser;
          
          -- XA transaction permissions (additional grants for completeness)
          GRANT SELECT ON sys.dba_pending_transactions TO testuser;
          GRANT SELECT ON sys.pending_trans$ TO testuser;
          GRANT SELECT ON sys.dba_2pc_pending TO testuser;
          GRANT SELECT ON sys.dba_2pc_neighbors TO testuser;
          GRANT EXECUTE ON sys.dbms_xa TO testuser;
          GRANT EXECUTE ON sys.dbms_system TO testuser;
          GRANT FORCE ANY TRANSACTION TO testuser;
          
          -- Verify grants
          SELECT 'XA permissions granted successfully' AS status FROM dual;
          
          -- Show granted privileges and roles
          SELECT granted_role, grantee FROM dba_role_privs WHERE grantee = 'TESTUSER' ORDER BY granted_role;
          SELECT privilege, grantee FROM dba_sys_privs WHERE grantee = 'TESTUSER' ORDER BY privilege;
          SELECT owner, table_name, privilege, grantee FROM dba_tab_privs WHERE grantee = 'TESTUSER' ORDER BY owner, table_name;
          
          EXIT;
          EOF
          
          if [ $? -ne 0 ]; then
            echo "ERROR: Failed to grant XA permissions!"
            exit 1
          fi
          
          echo "=== XA permissions granted successfully ==="

      # Download Oracle JDBC driver and place in ojp-libs directory
      # We don't include it in the repository due to Oracle licensing
      # The driver will be loaded at runtime via the drop-in mechanism
      - name: Download Oracle JDBC Driver to ojp-libs
        run: |
          # Create ojp-libs directory
          mkdir -p ojp-server/ojp-libs
          
          # Download Oracle JDBC driver from Maven Central
          echo "=== Downloading Oracle JDBC driver ==="
          mvn dependency:copy \
            -Dartifact=com.oracle.database.jdbc:ojdbc11:23.8.0.25.04 \
            -DoutputDirectory=ojp-server/ojp-libs \
            -Dmdep.stripVersion=false
          
          # Verify the download
          echo "=== Oracle JDBC driver downloaded to ojp-libs ==="
          ls -lh ojp-server/ojp-libs/

      - name: Set up JDK 22 for build
        uses: actions/setup-java@v4
        with:
          java-version: 22
          distribution: 'temurin'
          cache: maven

      - name: Build and Install (ojp-grpc-commons) with JDK 22
        run: mvn clean install -pl ojp-grpc-commons -am -DskipTests -Dgpg.skip=true

      - name: Test (ojp-grpc-commons) with JDK 22
        run: mvn test -pl ojp-grpc-commons -Dgpg.skip=true

      - name: Build (ojp-server) with JDK 22
        run: mvn clean install -pl ojp-server -am -DskipTests -Dgpg.skip=true

      - name: Test and Run (ojp-server) with Oracle driver from ojp-libs
        run: |
          nohup java -Dojp.libs.path=ojp-server/ojp-libs -jar ojp-server/target/ojp-server-0.3.2-snapshot-shaded.jar > /tmp/ojp-server.log 2>&1 &
          echo $! > /tmp/ojp-server.pid

      - name: Wait for ojp-server to start
        run: sleep 10

      - name: Set up JDK ${{ matrix.java-version }} for ojp-jdbc-driver
        uses: actions/setup-java@v4
        with:
          java-version: ${{ matrix.java-version }}
          distribution: 'temurin'
          cache: maven

      - name: Build (ojp-jdbc-driver) with JDK ${{ matrix.java-version }}
        run: mvn clean install -pl ojp-jdbc-driver -am -DskipTests -Dgpg.skip=true

      # Run Oracle-specific tests with -DenableOracleTests flag
      - name: Test (ojp-jdbc-driver) with Oracle enabled
        run: mvn test -pl ojp-jdbc-driver -Dgpg.skip=true -DenableOracleTests=true

      - name: Show ojp-server.log
        if: always()  # ensures it runs even if previous steps fail
        run: cat /tmp/ojp-server.log || echo "/tmp/ojp-server.log not found"

  # ===========================================================================
  # JOB 10: SQL Server Integration Tests
  # ===========================================================================
  #
  # This job tests SQL Server integration using TestContainers.
  # TestContainers automatically manages the SQL Server container lifecycle,
  # so no manual container setup is needed.
  #
  # Database: SQL Server (via TestContainers)
  # Matrix strategy: Tests against Java 11, 17, 21, 22
  # Execution: Only runs AFTER build-test job succeeds (needs: [build-test])
  #
  # ===========================================================================
  sqlserver-tests:
    name: SQL Server Integration Tests (JDK ${{ matrix.java-version }})
    runs-on: ubuntu-latest
    # DEPENDENCY: This job only runs if build-test succeeds
    # This ensures we don't waste resources on SQL Server tests if H2 tests fail
    needs: [build-test]
    
    permissions:
      contents: read

    strategy:
      fail-fast: false
      matrix:
        java-version: [ 11, 17, 21, 22 ]

    steps:
      - name: Git checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # Download SQL Server JDBC driver and place in ojp-libs directory
      # Similar to Oracle and DB2, we handle it via drop-in mechanism
      - name: Download SQL Server JDBC Driver to ojp-libs
        run: |
          # Create ojp-libs directory
          mkdir -p ojp-server/ojp-libs
          
          # Download SQL Server JDBC driver from Maven Central
          echo "=== Downloading SQL Server JDBC driver ==="
          mvn dependency:copy \
            -Dartifact=com.microsoft.sqlserver:mssql-jdbc:12.8.2.jre11 \
            -DoutputDirectory=ojp-server/ojp-libs \
            -Dmdep.stripVersion=false
          
          # Verify the download
          echo "=== SQL Server JDBC driver downloaded to ojp-libs ==="
          ls -lh ojp-server/ojp-libs/

      - name: Set up JDK 22 for build
        uses: actions/setup-java@v4
        with:
          java-version: 22
          distribution: 'temurin'
          cache: maven

      - name: Build and Install (ojp-grpc-commons) with JDK 22
        run: mvn clean install -pl ojp-grpc-commons -am -DskipTests -Dgpg.skip=true

      - name: Test (ojp-grpc-commons) with JDK 22
        run: mvn test -pl ojp-grpc-commons -Dgpg.skip=true

      - name: Build (ojp-server) with JDK 22
        run: mvn clean install -pl ojp-server -am -DskipTests -Dgpg.skip=true

      - name: Test and Run (ojp-server) with SQL Server driver from ojp-libs
        run: |
          nohup java -Dojp.libs.path=ojp-server/ojp-libs -jar ojp-server/target/ojp-server-0.3.2-snapshot-shaded.jar > /tmp/ojp-server.log 2>&1 &
          echo $! > /tmp/ojp-server.pid

      - name: Wait for ojp-server to start
        run: sleep 10

      - name: Set up JDK ${{ matrix.java-version }} for ojp-jdbc-driver
        uses: actions/setup-java@v4
        with:
          java-version: ${{ matrix.java-version }}
          distribution: 'temurin'
          cache: maven

      - name: Build (ojp-jdbc-driver) with JDK ${{ matrix.java-version }}
        run: mvn clean install -pl ojp-jdbc-driver -am -DskipTests -Dgpg.skip=true

      # Run SQL Server-specific tests
      # Uses -DenableSqlServerTests=true flag and filters to SQLServer* test classes
      # TestContainers will automatically start a SQL Server container for these tests
      - name: Run SQL Server Integration Tests
        run: |
          mvn test -pl ojp-jdbc-driver -Dgpg.skip=true \
            -DenableSqlServerTests=true \
            -Dtest="SQLServer*"

      - name: Show ojp-server.log
        if: always()  # ensures it runs even if previous steps fail
        run: cat /tmp/ojp-server.log || echo "/tmp/ojp-server.log not found"

  # ===========================================================================
  # JOB 11: Notify Integration Repository
  # ===========================================================================
  #
  # This job triggers a workflow in the ojp-framework-integration repository
  # to run integration tests with the latest OJP changes.
  #
  # Note: This job depends on build-test (H2 tests) completing successfully.
  # It only notifies the integration repo if the main H2 tests pass.
  #
  # ===========================================================================
  notify-integration:
    needs: [build-test]
    runs-on: ubuntu-latest
    steps:
      - name: Trigger OJP Framework Integration Repo Workflow
        uses: peter-evans/repository-dispatch@v3
        with:
          token: ${{ secrets.INTEGRATION_REPO_PAT }}
          repository: Open-J-Proxy/ojp-framework-integration
          event-type: ojp-updated
